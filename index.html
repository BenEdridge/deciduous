<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Attack Trees</title>
    <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style type="text/css">
        body, html {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
        #inputSource {
            display: block;
            width: 100%;
            height: 40vh;
            resize: none;
            border: medium none;
            appearance: none;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            outline: 0;
            overflow: auto;
            padding: 0;
            border-bottom: 1px solid grey;
        }
        #renderTarget {
            height: 60vh;
            overflow: auto;
        }
    </style>
</head>

<body>
    <textarea id="inputSource">
title: Attack Tree for S3 Bucket with Video Recordings

goals:
  s3_asset:
    title: "Access video\nrecordings in\nS3 bucket\n(attackers win)"
    from:
    - wayback: '#yolosec'
    - bucket_search

facts:
  wayback:
    title: "API cache\n(e.g. Wayback\nMachine)"
    from:
    - reality: '#yolosec'
  bucket_public:
    title: "S3 bucket\nset to public"
    from:
    - reality: '#yolosec'

attacks:
  bucket_search:
    title: "AWS public\nbuckets search"
    from:
    - disallow_crawling
  brute_force:
    title: "Brute force"
    from:
    - auth_required

mitigations:
  auth_required:
    title: "Auth required / ACLs\n(private bucket)"
    from:
    - reality
  disallow_crawling:
    title: "Disallow\ncrawling\non site maps"
    from:
    - reality
</textarea>
    <a id="downloadLink" download="decision-tree.svg"><div id="renderTarget"></div></a>
    <script>
        function line(name, properties) {
            const entries = Object.entries(properties);
            if (entries.length == 0) {
                return name;
            }
            return name + "[ " + entries.map(([key, value]) => `${key}=${JSON.stringify(value)}`).join(" ") + " ]";
        }
        function nodes(entries, properties) {
            return entries.map(([name, value]) => line(name, {
                label: typeof value == "string" ? value : value.title,
                ...properties,
            }));
        }
        function edges(entries, properties) {
            return entries.reduce((edges, [name, value]) => {
                (value.from || []).forEach((from) => {
                    if (typeof from == "object") {
                        from = Object.entries(from)[0];
                        edges.push(line(`${from[0]} -> ${name}`, {
                            xlabel: from[1],
                            fontcolor: "#DB2955",
                            ...properties,
                        }));
                    } else {
                        edges.push(line(`${from} -> ${name}`, properties));
                    }
                });
                return edges;
            }, []);
        }
        function convertToDot(yaml) {
            const parsed = jsyaml.load(yaml);
            console.log(parsed);
            const font = 'Arial'
            const header = `digraph {
    // Base Styling
    rankdir="TB";
    splines=true;
    overlap=false;
    nodesep="0.2";
    ranksep="0.4";
    label=${JSON.stringify(String(parsed.title))};
    labelloc="t";
    fontname=${JSON.stringify(font)};
    node [ shape="plaintext" style="filled, rounded" fontname=${JSON.stringify(font)} margin=0.2 ]
    edge [ fontname=${JSON.stringify(font)} color="#2B303A" ]

    reality [ label="Reality" fillcolor="#2B303A" fontcolor="#ffffff" ]
`;
            const goals = Object.entries(parsed.goals || {});
            const attacks = Object.entries(parsed.attacks || {});
            const mitigations = Object.entries(parsed.mitigations || {});
            const facts = Object.entries(parsed.facts || {});
            const allNodes = nodes(goals, {
                fillcolor: "#DB2955",
                fontcolor: "#ffffff",
            }).concat(nodes(attacks, {
                fillcolor: "#ED96AC",
            })).concat(nodes(mitigations, {
                fillcolor: "#ABD2FA",
            })).concat(nodes(facts, {
                fillcolor: "#C6CCD2",
            }));
            const allEdges = edges(goals, {}).concat(edges(attacks, {})).concat(edges(mitigations, {})).concat(edges(facts, {}));
            const footer = '}'
            return [header + allNodes.join("\n") + "\n" + allEdges.join("\n") + "\n" + footer, parsed.title];
        }
        const renderTarget = document.getElementById("renderTarget");
        const inputSource = document.getElementById("inputSource");
        const downloadLink = document.getElementById("downloadLink");
        window["@hpcc-js/wasm"].graphvizSync().then(graphviz => {
            let lastInput = "";
            let lastObjectURL = "";
            function rerender() {
                const newInput = inputSource.value;
                if (newInput != lastInput) {
                    lastInput = newInput;
                    // try {
                        const [dot, title] = convertToDot(newInput);
                        console.log(dot);
                        const svg = graphviz.layout(dot, "svg", "dot");
                        renderTarget.innerHTML = svg;
                        if (window.File && URL.createObjectURL) {
                            const file = new File([svg], "graph.svg", {
                                "type": "image/svg+xml",
                            });
                            const newObjectURL = URL.createObjectURL(file);
                            downloadLink.href = newObjectURL;
                            downloadLink.download = title + ".svg";
                            if (lastObjectURL != "") {
                                URL.revokeObjectURL(lastObjectURL);
                            }
                            lastObjectURL = newObjectURL;
                        }
                    // } catch (e) {
                    //     renderTarget.innerText = String(e);
                    //     downloadLink.removeAttribute("href");
                    // }
                }
            }
            inputSource.addEventListener("change", rerender, false);
            inputSource.addEventListener("input", rerender, false);
            rerender();
        });
    </script>

</body>

</html>